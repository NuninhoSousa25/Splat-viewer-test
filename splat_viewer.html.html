<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = async function () {
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.1);

   // Create and configure an ArcRotateCamera (free camera)
    var camera = new BABYLON.ArcRotateCamera("Camera", -1, 1.1, 4, new BABYLON.Vector3(0, 0, 0), scene);
    camera.attachControl(canvas, true);

    // Adjust camera clipping distances
    camera.minZ = 0.1; // Near clipping distance
    camera.maxZ = 1000; // Far clipping distance

    // Set camera sensitivities
    camera.panningSensibility = 1000;
    camera.angularSensibilityX = 2500;
    camera.angularSensibilityY = 2500;
    

   // Detect if the device is a mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    console.log("Is mobile device:", isMobile);

    if (isMobile) {
        camera.wheelPrecision = 7500; // Less sensitive zoom for mobile
        camera.pinchPrecision = 75; // Adjust pinch-to-zoom sensitivity for mobile
        console.log("Mobile zoom sensitivity applied:", camera.wheelPrecision);
    } else {
        camera.wheelPrecision = 100; // Original zoom sensitivity for desktop
        console.log("Desktop zoom sensitivity applied:", camera.wheelPrecision);
    }

    camera.panningInertia = 0.6;
    camera.useAutoRotationBehavior = true;

     if (camera.useAutoRotationBehavior) {
        const autoRotationBehavior = camera.autoRotationBehavior;
        autoRotationBehavior.idleRotationWaitTime = 5000;
        autoRotationBehavior.idleRotationSpeed = 0.01;
        autoRotationBehavior.idleRotationSpinUpTime = 3000;
    } else {
        camera.target = new BABYLON.Vector3(0, 0, 0);
        camera.alpha = -1;
        camera.beta = 1.1;
    }


    var gs;

    const loadModel = async (url) => {
        if (gs) {
            gs.dispose(); // Remove existing model if loaded
        }
        gs = new BABYLON.GaussianSplattingMesh("gs", null, scene);
        await gs.loadFileAsync(url);
    };

    // Load the default model
    const defaultModelUrl = "https://raw.githubusercontent.com/CedricGuillemet/dump/master/Halo_Believe.splat";
    await loadModel(defaultModelUrl);

    engine.displayLoadingUI();
    scene.executeWhenReady(function () {
        engine.hideLoadingUI();
    });

    scene.onBeforeRenderObservable.add(() => {
        camera.beta = Math.max(Math.min(camera.beta, 1.75), 0.2);
       // camera.radius = Math.max(Math.min(camera.radius, 7.0), 1.1);
    });

 // Handle double-click events to pan the camera smoothly
scene.onPointerObservable.add((pointerInfo) => {
    if (
        pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOUBLETAP &&
        pointerInfo.event.button === 0 // Check if it's a left double-click
    ) {
        const pickResult = scene.pick(scene.pointerX, scene.pointerY);
        if (pickResult.hit && pickResult.pickedPoint) {
            // Create an animation for the camera's target
            const animation = new BABYLON.Animation(
                "cameraPan",
                "target",
                50, // Frames per second
                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            // Set up keyframes for the animation
            const currentTarget = camera.target.clone();
            const keyFrames = [
                {
                    frame: 0,
                    value: currentTarget, // Start at the current target
                },
                {
                    frame: 50, // Animation duration in frames
                    value: pickResult.pickedPoint, // End at the picked point
                },
            ];
            animation.setKeys(keyFrames);

            // Add the animation to the camera
            camera.animations = [];
            camera.animations.push(animation);

            // Start the animation
            scene.beginAnimation(camera, 0, 50, false); // No loop
        }
    }
});

    const controlPanel = document.createElement("div");
    controlPanel.id = "controlPanel";
    controlPanel.style.position = "absolute";
    controlPanel.style.top = "10px";
    controlPanel.style.right = "10px";
    controlPanel.style.width = "250px";
    controlPanel.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    controlPanel.style.color = "white";
    controlPanel.style.padding = "10px";
    controlPanel.style.borderRadius = "5px";

    controlPanel.innerHTML = `
        <div id="controlPanelHeader" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0;">Controls</h3>
            <span id="toggleArrow" style="font-size: 16px;">▼</span>
        </div>
        <div id="controlPanelContent" style="display: none; margin-top: 10px;">
            <h4>Camera Controls</h4>
            <ul style="margin: 0; padding-left: 20px; list-style-type: square;">
                <li>Left click: Center on selection</li>
                <li>Right click: Pan</li>
                <li>Left click and drag: Orbit</li>
                <li>Scroll: Zoom</li>
            </ul>
            <label style="display: block; margin-top: 10px;">
                <input type="checkbox" id="autoRotateToggle" ${camera.useAutoRotationBehavior ? "checked" : ""}>
                Enable Auto-Rotate
            </label>
            
            <h4 style="margin-top: 15px;">Load 3D Model</h4>
            <input type="file" id="modelLoader" accept=".splat" style="margin-bottom: 10px;" />
            <button id="loadModelFileButton">Load from File</button>
            <br/><br/>
            <input type="text" id="modelUrlInput" placeholder="Enter model URL" style="width: 100%; margin-bottom: 10px;" />
            <button id="loadModelUrlButton">Load from URL</button>
            <h4 style="margin-top: 15px;">Performance Stats</h4>
                 <p>FPS: <span id="controlPanelFps">0</span></p>
                 <p>Resolution: <span id="controlPanelResolution">0 x 0</span></p>

        </div>
    `;

    document.body.appendChild(controlPanel);

    document.getElementById("controlPanelHeader").addEventListener("click", () => {
        const controlPanelContent = document.getElementById("controlPanelContent");
        const isExpanded = controlPanelContent.style.display === "block";
        controlPanelContent.style.display = isExpanded ? "none" : "block";
        document.getElementById("toggleArrow").textContent = isExpanded ? "▼" : "▲";
    });

    const controlPanelFps = document.getElementById("controlPanelFps");
const controlPanelResolution = document.getElementById("controlPanelResolution");

scene.onBeforeRenderObservable.add(() => {
    controlPanelFps.textContent = engine.getFps().toFixed(2);
    controlPanelResolution.textContent = `${engine.getRenderWidth()} x ${engine.getRenderHeight()}`;

});
    document.getElementById("loadModelFileButton").addEventListener("click", async () => {
        const fileInput = document.getElementById("modelLoader");
        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            const fileURL = URL.createObjectURL(file);
            await loadModel(fileURL);
        } else {
            alert("Please select a .splat file to load.");
        }
    });

    document.getElementById("loadModelUrlButton").addEventListener("click", async () => {
        const urlInput = document.getElementById("modelUrlInput").value;
        if (urlInput) {
            await loadModel(urlInput);
        } else {
            alert("https://raw.githubusercontent.com/CedricGuillemet/dump/master/Halo_Believe.splat");
        }
    });


    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    

// Add control for camera radius in the control panel
const radiusControl = document.createElement("div");
radiusControl.innerHTML = `
    <h4 style="margin-top: 15px;">Camera Radius</h4>
    <label for="maxRadiusInput">Max Radius:</label>
    <input type="number" id="maxRadiusInput" value="7.0" style="width: 100%;" placeholder="Max">
`;
document.getElementById("controlPanelContent").appendChild(radiusControl);

const maxRadiusInput = document.getElementById("maxRadiusInput");

maxRadiusInput.addEventListener("change", () => {
    const newMax = parseFloat(maxRadiusInput.value);
    if (!isNaN(newMax) && newMax > 0) {
        camera.upperRadiusLimit = newMax;
        camera.radius = Math.min(camera.radius, newMax);
    }
});

// Ensure camera.radius respects the min and updated max radius
scene.onBeforeRenderObservable.add(() => {
    camera.radius = Math.max(camera.radius, 1.1); // Fixed minimum radius
    if (camera.upperRadiusLimit !== undefined) {
        camera.radius = Math.min(camera.radius, camera.upperRadiusLimit);
    }
});

// Ensure camera starts in a valid position and radius
scene.executeWhenReady(() => {
    // Set a valid radius (ensures it's not too small or too large)
    camera.radius = 4; // Adjust as needed
    camera.upperRadiusLimit = 7.0; // Optional: Define max zoom-out
    camera.lowerRadiusLimit = 1.1; // Optional: Define min zoom-in

    // Set initial alpha and beta to ensure proper orientation
    camera.alpha = -Math.PI / 4; // Adjust horizontal angle
    camera.beta = Math.PI / 3;   // Adjust vertical angle (avoid being too low or high)

    // Optionally, reset target if needed
    camera.target = new BABYLON.Vector3(0, 0, 0);
});

    return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
